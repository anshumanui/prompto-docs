{"ast":null,"code":"import PROMPTO_WORKER from '../player/PromptoWorkerListener';\nexport default class LineHandler {\n  static forDialect(dialect) {\n    const klass = LineHandler.dialectHandlers[dialect];\n    return new klass();\n  }\n\n  constructor() {\n    this.instructions = [{\n      pattern: /help/g,\n      handler: this.printHelp,\n      doc: \"help: print this\"\n    }, {\n      pattern: /\\?/g,\n      handler: this.printHelp,\n      doc: \"?: print this\"\n    }, {\n      pattern: /clear/g,\n      handler: this.clear,\n      doc: \"clear: clear screen\"\n    }, {\n      pattern: /show/g,\n      handler: this.showAll,\n      doc: \"show: show all declarations and variables\"\n    }, {\n      pattern: /delete (.*)/g,\n      handler: this.deleteOne,\n      doc: \"delete x: clear variable x\"\n    }, {\n      pattern: /reset/g,\n      handler: this.reset,\n      doc: \"reset: clear data\"\n    }, {\n      pattern: /dialect [e|E|o|O|m|M]/g,\n      handler: this.switchDialect,\n      doc: \"dialect E, M or O: switch to said dialect\"\n    }];\n  }\n\n  evaluate(promptValue, promptData, promptHistory, displayHistory, callback) {\n    let handler = this.collectMultiLine(promptValue, promptData, promptHistory, displayHistory, callback);\n    if (handler) return handler;\n    handler = this.handleEmptyLine(promptValue, promptData, promptHistory, displayHistory, callback);\n    if (handler) return handler;\n    handler = this.executeInstruction(promptValue, promptData, promptHistory, displayHistory, callback);\n    if (handler) return handler;\n    handler = this.interpretPrompto(promptValue, promptData, promptHistory, displayHistory, callback);\n    if (handler) return handler;else return this; // never return null handler\n  }\n\n  handleEmptyLine(promptValue, promptData, promptHistory, displayHistory, callback) {\n    if (promptValue.length === 0) {\n      displayHistory.push({\n        type: 'input',\n        data: \"\"\n      });\n      callback();\n      return this;\n    } else return null;\n  }\n\n  executeInstruction(promptValue, promptData, promptHistory, displayHistory, callback) {\n    const s = promptValue.trim().toLowerCase();\n    const instruction = this.instructions.find(i => s.match(i.pattern));\n\n    if (instruction) {\n      const result = instruction.handler.bind(this)(promptValue, promptData, promptHistory, displayHistory, callback);\n      return result || this;\n    } else return null;\n  }\n\n  printHelp(promptValue, promptData, promptHistory, displayHistory, callback) {\n    const promptItem = {\n      type: 'input',\n      data: promptValue\n    };\n    promptHistory.push(promptItem);\n    displayHistory.push(promptItem);\n    let data = this.instructions.map(i => i.doc);\n    data.push(\"( currently using dialect: \" + this.dialect + \" )\");\n    data = data.map(s => {\n      return {\n        type: 'welcome',\n        data: s\n      };\n    });\n    displayHistory.push(data);\n    callback();\n  }\n\n  clear(promptValue, promptData, promptHistory, displayHistory, callback) {\n    promptData.clear();\n    promptHistory.clear();\n    displayHistory.clear();\n    callback();\n  }\n\n  showAll(promptValue, promptData, promptHistory, displayHistory, callback) {\n    PROMPTO_WORKER.showRepl(this.dialect, (out, err, items) => {\n      const promptItem = {\n        type: 'input',\n        data: promptValue\n      };\n      promptHistory.push(promptItem);\n      displayHistory.push(promptItem);\n      if (out) displayHistory.push({\n        type: 'response',\n        data: out\n      });\n      items.forEach(item => displayHistory.push({\n        type: 'response',\n        data: item\n      }));\n      callback();\n    });\n  }\n\n  deleteOne(promptValue, promptData, promptHistory, displayHistory, callback) {\n    const name = promptValue.trim().substring(\"delete \".length);\n    PROMPTO_WORKER.deleteRepl(name, (out, err) => {\n      const promptItem = {\n        type: 'input',\n        data: promptValue\n      };\n      promptHistory.push(promptItem);\n      if (out) displayHistory.push([promptItem, {\n        type: 'response',\n        data: out\n      }]);else if (err) displayHistory.push([promptItem, {\n        type: 'error',\n        data: err\n      }]);\n      callback();\n    });\n  }\n\n  reset(promptValue, promptData, promptHistory, displayHistory, callback) {\n    PROMPTO_WORKER.resetRepl(() => {\n      const promptItem = {\n        type: 'input',\n        data: promptValue\n      };\n      promptHistory.push(promptItem);\n      displayHistory.push([promptItem, {\n        type: 'welcome',\n        data: \"All data has been deleted\"\n      }]);\n      callback();\n    });\n  }\n\n  switchDialect(promptValue, promptData, promptHistory, displayHistory, callback) {\n    const promptItem = {\n      type: 'input',\n      data: promptValue\n    };\n    promptHistory.push(promptItem);\n    displayHistory.push(promptItem);\n    promptValue = promptValue.substring(\"dialect \".length);\n    const dialect = promptValue.length ? promptValue.substring(promptValue.length - 1).toUpperCase() : \"\";\n\n    if (new Set([\"E\", \"O\", \"M\"]).has(dialect)) {\n      displayHistory.push({\n        type: 'welcome',\n        data: \"Using dialect: \" + dialect\n      });\n      callback();\n      return LineHandler.forDialect(dialect);\n    } else {\n      displayHistory.push({\n        type: 'error',\n        data: \"No such dialect: \" + dialect\n      });\n      callback();\n      return this;\n    }\n  }\n\n  interpretPrompto(promptValue, promptData, promptHistory, displayHistory, callback) {\n    PROMPTO_WORKER.repl(promptValue, this.dialect, (out, err) => {\n      const promptItem = {\n        type: 'input',\n        data: promptValue\n      };\n      promptHistory.push(promptItem);\n      if (out) displayHistory.push([promptItem, {\n        type: 'response',\n        data: out\n      }]);else if (err) displayHistory.push([promptItem, {\n        type: 'error',\n        data: err\n      }]);\n      callback();\n    });\n  }\n\n  interpretPromptoML(input, promptData, promptHistory, displayHistory, callback) {\n    PROMPTO_WORKER.repl(input, this.dialect, (out, err) => {\n      if (out) displayHistory.push({\n        type: 'response',\n        data: out\n      });else if (err) displayHistory.push({\n        type: 'error',\n        data: err\n      });\n      callback();\n    });\n  }\n\n}\n\nclass MLineHandler extends LineHandler {\n  constructor() {\n    super();\n    this.dialect = \"M\";\n  }\n\n  collectMultiLine(promptValue, promptData, promptHistory, displayHistory, callback) {\n    if (promptValue.trim().endsWith(\":\")) {\n      const promptItem = {\n        type: 'input',\n        data: promptValue,\n        indentLevel: promptData.indentLevel\n      };\n      promptHistory.push(promptItem);\n      displayHistory.push(promptItem);\n      promptData.addLine(promptValue);\n      promptData.indent();\n      callback();\n      return this;\n    } else if (promptData.indentLevel > 0) {\n      const promptItem = {\n        type: 'input',\n        data: promptValue,\n        indentLevel: promptData.indentLevel\n      };\n      promptHistory.push(promptItem);\n      displayHistory.push(promptItem);\n      promptData.addLine(promptValue);\n      callback();\n      return this;\n    } else if (promptValue.length === 0 && promptData.linesBefore.length > 0) {\n      const input = promptData.allLines();\n      promptData.clearLines();\n      this.interpretPromptoML(input, promptData, promptHistory, displayHistory, callback);\n      return this;\n    } else return null;\n  }\n\n} // eslint-disable-next-line\n\n\nclass ELineHandler extends MLineHandler {\n  constructor() {\n    super();\n    this.dialect = \"E\";\n  } // E and M dialects have the same indentation rules so no collectMultiLine override\n\n\n} // eslint-disable-next-line\n\n\nclass OLineHandler extends LineHandler {\n  constructor() {\n    super();\n    this.dialect = \"O\";\n  }\n\n  collectMultiLine(promptValue, promptData, promptHistory, displayHistory, callback) {\n    if (promptValue.trim().endsWith(\"{\")) {\n      const promptItem = {\n        type: 'input',\n        data: promptValue,\n        indentLevel: promptData.indentLevel\n      };\n      promptHistory.push(promptItem);\n      displayHistory.push(promptItem);\n      promptData.addLine(promptValue);\n      promptData.indent();\n      callback();\n      return this;\n    } else if (promptData.indentLevel > 0) {\n      const promptItem = {\n        type: 'input',\n        data: promptValue,\n        indentLevel: promptData.indentLevel\n      };\n      promptHistory.push(promptItem);\n      displayHistory.push(promptItem);\n      promptData.addLine(promptValue);\n      callback();\n      return this;\n    } else if (promptValue === \"}\" && promptData.linesBefore.length > 0) {\n      const promptItem = {\n        type: 'input',\n        data: promptValue,\n        indentLevel: promptData.indentLevel\n      };\n      promptHistory.push(promptItem);\n      displayHistory.push(promptItem);\n      promptData.addLine(promptValue);\n      const input = promptData.allLines();\n      promptData.clearLines();\n      this.interpretPromptoML(input, promptData, promptHistory, displayHistory, callback);\n      return this;\n    } else return null;\n  }\n\n}\n\nLineHandler.dialectHandlers = {\n  \"M\": MLineHandler,\n  \"E\": ELineHandler,\n  \"O\": OLineHandler\n};","map":{"version":3,"sources":["/Applications/XAMPP/xamppfiles/htdocs/prompto-docs/WebSite/src/resources/src/components/playground/LineHandler.js"],"names":["PROMPTO_WORKER","LineHandler","forDialect","dialect","klass","dialectHandlers","constructor","instructions","pattern","handler","printHelp","doc","clear","showAll","deleteOne","reset","switchDialect","evaluate","promptValue","promptData","promptHistory","displayHistory","callback","collectMultiLine","handleEmptyLine","executeInstruction","interpretPrompto","length","push","type","data","s","trim","toLowerCase","instruction","find","i","match","result","bind","promptItem","map","showRepl","out","err","items","forEach","item","name","substring","deleteRepl","resetRepl","toUpperCase","Set","has","repl","interpretPromptoML","input","MLineHandler","endsWith","indentLevel","addLine","indent","linesBefore","allLines","clearLines","ELineHandler","OLineHandler"],"mappings":"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","sourcesContent":["import PROMPTO_WORKER from '../player/PromptoWorkerListener';\n\nexport default class LineHandler {\n\n    static forDialect(dialect) {\n        const klass = LineHandler.dialectHandlers[dialect];\n        return new klass();\n    }\n\n    constructor() {\n        this.instructions = [\n            {pattern: /help/g, handler: this.printHelp, doc: \"help: print this\"},\n            {pattern: /\\?/g, handler: this.printHelp, doc: \"?: print this\"},\n            {pattern: /clear/g, handler: this.clear, doc: \"clear: clear screen\"},\n            {pattern: /show/g, handler: this.showAll, doc: \"show: show all declarations and variables\"},\n            {pattern: /delete (.*)/g, handler: this.deleteOne, doc: \"delete x: clear variable x\"},\n            {pattern: /reset/g, handler: this.reset, doc: \"reset: clear data\"},\n            {\n                pattern: /dialect [e|E|o|O|m|M]/g,\n                handler: this.switchDialect,\n                doc: \"dialect E, M or O: switch to said dialect\"\n            }\n        ];\n    }\n\n    evaluate(promptValue, promptData, promptHistory, displayHistory, callback) {\n        let handler = this.collectMultiLine(promptValue, promptData, promptHistory, displayHistory, callback);\n        if (handler)\n            return handler;\n        handler = this.handleEmptyLine(promptValue, promptData, promptHistory, displayHistory, callback);\n        if (handler)\n            return handler;\n        handler = this.executeInstruction(promptValue, promptData, promptHistory, displayHistory, callback);\n        if (handler)\n            return handler;\n        handler = this.interpretPrompto(promptValue, promptData, promptHistory, displayHistory, callback);\n        if (handler)\n            return handler;\n        else\n            return this; // never return null handler\n    }\n\n    handleEmptyLine(promptValue, promptData, promptHistory, displayHistory, callback) {\n        if (promptValue.length === 0) {\n            displayHistory.push({type: 'input', data: \"\"});\n            callback();\n            return this;\n        } else\n            return null;\n    }\n\n    executeInstruction(promptValue, promptData, promptHistory, displayHistory, callback) {\n        const s = promptValue.trim().toLowerCase();\n        const instruction = this.instructions.find(i => s.match(i.pattern));\n        if (instruction) {\n            const result = instruction.handler.bind(this)(promptValue, promptData, promptHistory, displayHistory, callback);\n            return result || this;\n        } else\n            return null;\n    }\n\n    printHelp(promptValue, promptData, promptHistory, displayHistory, callback) {\n        const promptItem = {type: 'input', data: promptValue};\n        promptHistory.push(promptItem);\n        displayHistory.push(promptItem);\n        let data = this.instructions.map(i => i.doc);\n        data.push(\"( currently using dialect: \" + this.dialect + \" )\");\n        data = data.map(s => {\n            return {type: 'welcome', data: s};\n        });\n        displayHistory.push(data);\n        callback();\n    }\n\n    clear(promptValue, promptData, promptHistory, displayHistory, callback) {\n        promptData.clear();\n        promptHistory.clear();\n        displayHistory.clear();\n        callback();\n    }\n\n    showAll(promptValue, promptData, promptHistory, displayHistory, callback) {\n        PROMPTO_WORKER.showRepl(this.dialect, (out, err, items) => {\n            const promptItem = {type: 'input', data: promptValue};\n            promptHistory.push(promptItem);\n            displayHistory.push(promptItem);\n            if (out)\n                displayHistory.push({type: 'response', data: out});\n            items.forEach(item => displayHistory.push({type: 'response', data: item}));\n            callback();\n        });\n    }\n\n    deleteOne(promptValue, promptData, promptHistory, displayHistory, callback) {\n        const name = promptValue.trim().substring(\"delete \".length);\n        PROMPTO_WORKER.deleteRepl(name, (out, err) => {\n            const promptItem = {type: 'input', data: promptValue};\n            promptHistory.push(promptItem);\n            if (out)\n                displayHistory.push([promptItem, {type: 'response', data: out}]);\n            else if (err)\n                displayHistory.push([promptItem, {type: 'error', data: err}]);\n            callback();\n        });\n    }\n\n    reset(promptValue, promptData, promptHistory, displayHistory, callback) {\n        PROMPTO_WORKER.resetRepl(() => {\n            const promptItem = {type: 'input', data: promptValue};\n            promptHistory.push(promptItem);\n            displayHistory.push([promptItem, {type: 'welcome', data: \"All data has been deleted\"}]);\n            callback();\n        });\n    }\n\n    switchDialect(promptValue, promptData, promptHistory, displayHistory, callback) {\n        const promptItem = {type: 'input', data: promptValue};\n        promptHistory.push(promptItem);\n        displayHistory.push(promptItem);\n        promptValue = promptValue.substring(\"dialect \".length);\n        const dialect = promptValue.length ? promptValue.substring(promptValue.length - 1).toUpperCase() : \"\";\n        if (new Set([\"E\", \"O\", \"M\"]).has(dialect)) {\n            displayHistory.push({type: 'welcome', data: \"Using dialect: \" + dialect});\n            callback();\n            return LineHandler.forDialect(dialect);\n        } else {\n            displayHistory.push({type: 'error', data: \"No such dialect: \" + dialect});\n            callback();\n            return this;\n        }\n    }\n\n    interpretPrompto(promptValue, promptData, promptHistory, displayHistory, callback) {\n        PROMPTO_WORKER.repl(promptValue, this.dialect, (out, err) => {\n            const promptItem = {type: 'input', data: promptValue};\n            promptHistory.push(promptItem);\n            if (out)\n                displayHistory.push([promptItem, {type: 'response', data: out}]);\n            else if (err)\n                displayHistory.push([promptItem, {type: 'error', data: err}]);\n            callback();\n        });\n    }\n\n    interpretPromptoML(input, promptData, promptHistory, displayHistory, callback) {\n        PROMPTO_WORKER.repl(input, this.dialect, (out, err) => {\n            if (out)\n                displayHistory.push({type: 'response', data: out});\n            else if (err)\n                displayHistory.push({type: 'error', data: err});\n            callback();\n        });\n    }\n\n}\n\n\nclass MLineHandler extends LineHandler {\n\n    constructor() {\n        super();\n        this.dialect = \"M\";\n    }\n\n    collectMultiLine(promptValue, promptData, promptHistory, displayHistory, callback) {\n        if (promptValue.trim().endsWith(\":\")) {\n            const promptItem = {type: 'input', data: promptValue, indentLevel: promptData.indentLevel};\n            promptHistory.push(promptItem);\n            displayHistory.push(promptItem);\n            promptData.addLine(promptValue);\n            promptData.indent();\n            callback();\n            return this;\n        } else if (promptData.indentLevel > 0) {\n            const promptItem = {type: 'input', data: promptValue, indentLevel: promptData.indentLevel};\n            promptHistory.push(promptItem);\n            displayHistory.push(promptItem);\n            promptData.addLine(promptValue);\n            callback();\n            return this;\n        } else if (promptValue.length === 0 && promptData.linesBefore.length > 0) {\n            const input = promptData.allLines();\n            promptData.clearLines();\n            this.interpretPromptoML(input, promptData, promptHistory, displayHistory, callback);\n            return this;\n        } else\n            return null;\n    }\n\n}\n\n// eslint-disable-next-line\nclass ELineHandler extends MLineHandler {\n\n    constructor() {\n        super();\n        this.dialect = \"E\";\n    }\n\n    // E and M dialects have the same indentation rules so no collectMultiLine override\n\n\n}\n\n// eslint-disable-next-line\nclass OLineHandler extends LineHandler {\n\n    constructor() {\n        super();\n        this.dialect = \"O\";\n    }\n\n    collectMultiLine(promptValue, promptData, promptHistory, displayHistory, callback) {\n        if (promptValue.trim().endsWith(\"{\")) {\n            const promptItem = {type: 'input', data: promptValue, indentLevel: promptData.indentLevel};\n            promptHistory.push(promptItem);\n            displayHistory.push(promptItem);\n            promptData.addLine(promptValue);\n            promptData.indent();\n            callback();\n            return this;\n        } else if (promptData.indentLevel > 0) {\n            const promptItem = {type: 'input', data: promptValue, indentLevel: promptData.indentLevel};\n            promptHistory.push(promptItem);\n            displayHistory.push(promptItem);\n            promptData.addLine(promptValue);\n            callback();\n            return this;\n        } else if (promptValue === \"}\" && promptData.linesBefore.length > 0) {\n            const promptItem = {type: 'input', data: promptValue, indentLevel: promptData.indentLevel};\n            promptHistory.push(promptItem);\n            displayHistory.push(promptItem);\n            promptData.addLine(promptValue);\n            const input = promptData.allLines();\n            promptData.clearLines();\n            this.interpretPromptoML(input, promptData, promptHistory, displayHistory, callback);\n            return this;\n        } else\n            return null;\n    }\n\n}\n\n\nLineHandler.dialectHandlers = {\n    \"M\": MLineHandler,\n    \"E\": ELineHandler,\n    \"O\": OLineHandler\n};"]},"metadata":{},"sourceType":"module"}